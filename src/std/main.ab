pub fun input(prompt: Text): Text {
    unsafe $printf "\${nameof prompt}"$
    unsafe $read$
    return "$REPLY"
}

pub fun replace_once(source, pattern, replacement) {
    return unsafe $echo "\$\{source/{pattern}/{replacement}}"$
}

pub fun replace(source, pattern, replacement) {
    return unsafe $echo "\$\{source//{pattern}/{replacement}}"$
}

pub fun replace_regex(source: Text, pattern: Text, replacement: Text): Text {
    return unsafe $echo "{source}" | sed -e "s/{pattern}/{replacement}/g"$
}

pub fun dir_exist(path) {
    $[ -d "{path}" ]$ failed {
        return false
    }
    return true
}

pub fun file_exist(path) {
    $[ -f "{path}" ]$ failed {
        return false
    }
    return true
}

pub fun file_read(path) {
    return $cat "{path}"$?
}

pub fun file_write(path, content) {
    return $echo "{content}" > "{path}"$?
}

pub fun file_append(path, content) {
    return $echo "{content}" >> "{path}"$?
}

pub fun split(text: Text, delimiter: Text): [Text] {
    let result = [Text]
    unsafe $IFS="{delimiter}" read -ra {nameof result} <<< "\${nameof text}"$
    return result
}

pub fun lines(text: Text): [Text] {
    let result = [Text]
    unsafe $IFS=\$'\n' read -rd '' -a {nameof result} <<<"\${nameof text}"$
    return result
}

pub fun words(text: Text): [Text] {
  return split(text, " ")
}

pub fun join(list: [Text], delimiter: Text): Text {
    return unsafe $IFS="{delimiter}" ; echo "\$\{{nameof list}[*]}"$
}

pub fun trim_left(text: Text): Text {
    return unsafe $echo "{text}" | sed -e 's/^[[:space:]]*//'$
}

pub fun trim_right(text: Text): Text {
    return unsafe $echo "{text}" | sed -e 's/[[:space:]]*\$//'$
}

pub fun trim(text: Text): Text {
    return trim_left(trim_right(text))
}

pub fun lower(text: Text): Text {
    return unsafe $echo "{text}" | tr '[:upper:]' '[:lower:]'$
}

pub fun upper(text: Text): Text {
    return unsafe $echo "{text}" | tr '[:lower:]' '[:upper:]'$
}

#[allow_absurd_cast]
pub fun len(value): Num {
    unsafe {
        if value is Text:
            return $echo "\$\{#{nameof value}}"$ as Num
        else:
            return $echo "\$\{#{nameof value}[@]}"$ as Num
    }
}

#[allow_absurd_cast]
pub fun parse(text: Text): Num {
    $[ -n "{text}" ] && [ "{text}" -eq "{text}" ] 2>/dev/null$?
    return text as Num
}

pub fun chars(text: Text): [Text] {
    let chars = [Text]
    unsafe $for ((i=0; i<\$\{#{nameof text}}; i++)); do
        {nameof chars}+=( "\$\{{nameof text}:\$i:1}" );
    done;$
    return chars
}

#[allow_absurd_cast]
pub fun sum(list: [Num]): Num {
    return unsafe $echo "{list}" | awk '\{s=0; for (i=1; i<=NF; i++) s+=\$i; print s}'$ as Num
}

pub fun has_failed(command: Text): Bool {
    unsafe silent $eval {command}$
    return status != 0
}

pub fun exit(code: Num): Null {
    unsafe $exit "{code}"$
}

pub fun includes(arr, value) {
    loop v in arr {
        if v == value {
            return true
        }
    }
    return false
}

pub fun is_command(command: Text): Bool {
    if (unsafe $command -v "{command}" > /dev/null$) {
        return true
    }
    return false
}

pub fun create_symbolic_link(origin: Text, destination: Text): Bool {
    if file_exist(origin) {
        unsafe $ln -s "{origin}" "{path}"$
        return true
    }

    echo "The file {origin} doesn't exist!"
    return false
}

pub fun create_dir(path: Text): Null {
    if not dir_exist(origin) {
        unsafe $mkdir -p "{path}"$
    }
}

pub fun make_executable(path: Text): Bool {
    if file_exist(origin) {
        unsafe $chmod +x "{path}"$
        return true
    }

    echo "The file {path} doesn't exist!"
    return false
}

pub fun switch_user_permission(user: Text, path: Text): Bool {
    if file_exist(origin) or dir_exist(origin) {
        unsafe $chown -R "{user}" "{path}"$
        return true
    }

    return false
}

pub fun download(url: Text, path: Text): Bool {
    if {
        not is_command("curl") {
            unsafe $curl -o "{path}" "{url}"$
        }
        not is_command('wget')) {
            unsafe $wget "{url}" -P "{path}"$
        }
        not is_command('aria2c')) {
            unsafe $aria2c "{url}" -d "{path}"$
        }
        return true
    }
    return false
}

pub fun is_root(): Bool {
    id = unsafe $id -u$
    if (id == 0) {
        return true
    }
    return false
}
