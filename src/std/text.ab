// We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.
// This is a workaround to avoid that issue and the import system should be improved in the future.
#[allow_absurd_cast]
fun bash_version(): [Int] {
    let major = 0
    let minor = 0
    let patch = 0
    trust $
        {nameof major}=\$\{BASH_VERSINFO[0]}
        {nameof minor}=\$\{BASH_VERSINFO[1]}
        {nameof patch}=\$\{BASH_VERSINFO[2]}
    $
    return [major, minor, patch]
}

/// Replaces all occurrences of a pattern in the content with the provided replace text.
///
/// ### Usage
/// ```ab
/// let result = replace("Hello world", "world", "universe")
/// echo result // "Hello universe"
/// ```
pub fun replace(source, search, replace) {
    // Here we use a command to avoid #646
    let result = ""
    if bash_version() >= [4,3] {
        trust $ {nameof result}="\$\{{nameof source}//"\$\{{nameof search}}"/"\$\{{nameof replace}}"}" $
    } else {
        trust $ {nameof result}="\$\{{nameof source}//"\$\{{nameof search}}"/\$\{{nameof replace}}}" $
    }
    return result
}

/// Replaces the first occurrence of a pattern in the content with the provided replace text.
///
/// ### Usage
/// ```ab
/// let result = replace_one("foo foo foo", "foo", "bar")
/// echo result // "bar foo foo"
/// ```
pub fun replace_one(source, search, replace) {
    // Here we use a command to avoid #646
    let result = ""
    if bash_version() >= [4,3] {
        trust $ {nameof result}="\$\{{nameof source}/"\$\{{nameof search}}"/"\$\{{nameof replace}}"}" $
    } else {
        trust $ {nameof result}="\$\{{nameof source}/"\$\{{nameof search}}"/\$\{{nameof replace}}}" $
    }
    return result
}

const SED_VERSION_UNKNOWN = 0
const SED_VERSION_GNU = 1
const SED_VERSION_BUSYBOX = 2

fun sed_version(): Int {
    // We can't match against a word "GNU" because
    // alpine's busybox sed returns "This is not GNU sed version"
    trust $ re='\bCopyright\b.+\bFree Software Foundation\b'; [[ \$(sed --version 2>/dev/null) =~ \$re ]] $
    if status == 0 {
        return SED_VERSION_GNU
    }
    // On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.
    trust $ re='\bBusyBox\b'; [[ \$(sed --help 2>&1) =~ \$re ]] $
    if status == 0 {
        return SED_VERSION_BUSYBOX
    }
    return SED_VERSION_UNKNOWN
}

/// Replaces all occurrences of a regex pattern in the content with the provided replace text.
///
/// Function uses `sed`
///
/// ### Usage
/// ```ab
/// let result = replace_regex("test123", "[0-9]+", "456", true)
/// echo result // "test456"
/// ```
pub fun replace_regex(source: Text, search: Text, replace_text: Text, extended: Bool = false): Text {
    trust {
        const sed_version = sed_version()
        search = replace(search, "/", "\\/")
        replace_text = replace(replace_text, "/", "\\/")
        if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
            // '\b' is supported but not in POSIX standards. Disable it
            search = replace(search, "\\b", "\\\b")
        }
        if extended {
            // GNU sed versions 4.0 through 4.2 support extended regex syntax,
            // but only via the "-r" option
            if sed_version == SED_VERSION_GNU {
                return $ echo "{source}" | sed -r -e "s/{search}/{replace_text}/g" $
            } else {
                return $ echo "{source}" | sed -E -e "s/{search}/{replace_text}/g" $
            }
        } else {
            if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
                // GNU Sed BRE handle \| as a metacharacter, but it is not POSIX standands. Disable it
                search = replace(search, "\|", "|")
            }
            return $ echo "{source}" | sed -e "s/{search}/{replace_text}/g" $
        }
    }
}

/// Splits the input `text` into an array of substrings using the specified `delimiter`.
///
/// ### Usage
/// ```ab
/// let parts = split("a,b,c", ",")
/// echo parts[0] // "a"
/// ```
pub fun split(text: Text, delimiter: Text): [Text] {
    let result = [Text]
    trust $ IFS="{delimiter}" read -rd '' -a {nameof result} < <(printf %s "\${nameof text}") $
    return result
}

/// Splits a `text` into an array of substrings based on newline characters.
///
/// ### Usage
/// ```ab
/// let lines = split_lines("line1\nline2\nline3")
/// echo lines[0] // "line1"
/// ```
pub fun split_lines(text: Text): [Text] {
    return split(text, "\n")
}

/// Splits a `text` into an array of substrings based on space character.
///
/// ### Usage
/// ```ab
/// let words = split_words("hello world example")
/// echo words[1] // "world"
/// ```
pub fun split_words(text: Text): [Text] {
    return split(text, " ")
}

/// Merges text using the delimiter specified.
///
/// ### Usage
/// ```ab
/// let joined = join(["a", "b", "c"], ",")
/// echo joined // "a,b,c"
/// ```
pub fun join(list: [Text], delimiter: Text): Text {
    return trust $ IFS="{delimiter}" ; echo "\$\{{nameof list}[*]}" $
}

/// Trims the spaces at top of the text using `sed`.
///
/// ### Usage
/// ```ab
/// let trimmed = trim_left("   hello")
/// echo trimmed // "hello"
/// ```
pub fun trim_left(text: Text): Text {
    return trust $ echo "{text}" | sed -e 's/^[[:space:]]*//' $
}

/// Trims the spaces at end of the text using `sed`.
///
/// ### Usage
/// ```ab
/// let trimmed = trim_right("hello   ")
/// echo trimmed // "hello"
/// ```
pub fun trim_right(text: Text): Text {
    return trust $ echo "{text}" | sed -e 's/[[:space:]]*\$//' $
}

/// Trims the spaces from the text input.
///
/// ### Usage
/// ```ab
/// let trimmed = trim("   hello   ")
/// echo trimmed // "hello"
/// ```
pub fun trim(text: Text): Text {
    return trim_left(trim_right(text))
}

/// Makes the text input lowercase using `tr`.
///
/// ### Usage
/// ```ab
/// let lower = lowercase("HELLO")
/// echo lower // "hello"
/// ```
pub fun lowercase(text: Text): Text {
    return trust $ echo "{text}" | tr '[:upper:]' '[:lower:]' $
}

/// Makes the text input uppercase using `tr`.
///
/// ### Usage
/// ```ab
/// let upper = uppercase("hello")
/// echo upper // "HELLO"
/// ```
pub fun uppercase(text: Text): Text {
    return trust $ echo "{text}" | tr '[:lower:]' '[:upper:]' $
}

/// Attempts to parse a given text into an `Int` number.
///
/// ### Usage
/// ```ab
/// let num = parse_int("42")?
/// echo num // 42
/// ```
#[allow_absurd_cast]
pub fun parse_int(text: Text): Int? {
    $ [ -n "{text}" ] && [ "{text}" -eq "{text}" ] 2>/dev/null $?
    return text as Int
}

/// Attempts to parse a given text into a `Num` number.
///
/// ### Usage
/// ```ab
/// let num = parse_num("3.14")?
/// echo num // 3.14
/// ```
#[allow_absurd_cast]
pub fun parse_num(text: Text): Num? {
    let re_int="^-?[0-9]+$"
    let re_float="^-?[0-9]*\.[0-9]+$"

    $ [[ {text} =~ {re_int} ]] || [[ {text} =~ {re_float} ]] $?
    return text as Num
}

/// Splits a text into an array of individual characters.
///
/// ### Usage
/// ```ab
/// let chars = split_chars("hello")
/// echo chars[0] // "h"
/// ```
pub fun split_chars(text: Text): [Text] {
    let chars = [Text]
    trust $ for ((i=0; i<\$\{#{nameof text}}; i++)); do
        {nameof chars}+=( "\$\{{nameof text}:\$i:1}" );
    done $
    return chars
}

/// Checks if some text contains a value.
///
/// ### Usage
/// ```ab
/// if text_contains("hello world", "world") {
///     echo "Found!"
/// }
/// ```
pub fun text_contains(source: Text, search: Text): Bool {
    trust $ [[ "{source}" == *"{search}"* ]] $
    return status == 0
}

/// Checks if an array value is in the text.
///
/// ### Usage
/// ```ab
/// if text_contains_any("hello world", ["foo", "world", "bar"]) {
///     echo "Found at least one!"
/// }
/// ```
pub fun text_contains_any(source: Text, searches: [Text]): Bool {
    for search in searches {
        if text_contains(source, search) {
            return true
        }
    }

    return false
}

/// Checks if all the arrays values are in the string
///
/// ### Usage
/// ```ab
/// if text_contains_all("hello world", ["hello", "world"]) {
///     echo "All found!"
/// }
/// ```
pub fun text_contains_all(source: Text, searches: [Text]): Bool {
    for search in searches {
        if not text_contains(source, search) {
            return false
        }
    }
    return true
}

/// Match all occurrences of a regex pattern.
///
/// Function uses `sed`
///
/// ### Usage
/// ```ab
/// if match_regex("test123", "[0-9]+", true) {
///     echo "Contains numbers!"
/// }
/// ```
pub fun match_regex(source: Text, search: Text, extended: Bool = false): Bool {
    trust {
        const sed_version = sed_version()
        search = replace(search, "/", "\/")
        let output = ""
        if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
            // '\b' is supported but not in POSIX standards. Disable it
            search = replace(search, "\\b", "\\\b")
        }
        if extended {
            // GNU sed versions 4.0 through 4.2 support extended regex syntax,
            // but only via the "-r" option
            if sed_version == SED_VERSION_GNU {
                // '\b' is not in POSIX standards. Disable it
                search = replace(search, "\b", "\\b")
                output = $ echo "{source}" | sed -r -ne "/{search}/p" $
            } else {
                output = $ echo "{source}" | sed -E -ne "/{search}/p" $
            }
        } else {
            if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
                // GNU Sed BRE handle \| as a metacharacter, but it is not POSIX standands. Disable it
                search = replace(search, "\|", "|")
            }
            output = $ echo "{source}" | sed -ne "/{search}/p" $
        }
        if output != "" {
            return true
        }
    }
    return false
}

/// Checks if an array value (with regular expression) is in the text.
///
/// ### Usage
/// ```ab
/// if match_regex_any("test123", ["[a-z]+", "[0-9]+"]) {
///     echo "Matches at least one pattern!"
/// }
/// ```
pub fun match_regex_any(text: Text, terms: [Text]): Bool {
    for term in terms {
        if match_regex(text, term, false) {
            return true
        }
    }

    return false
}

/// Reverses text using `rev`.
///
/// ### Usage
/// ```ab
/// let reversed_text = reversed("hello")
/// echo reversed_text // "olleh"
/// ```
pub fun reversed(text: Text): Text {
    return trust $ echo "{text}" | rev $
}

/// Checks if text starts with a value.
///
/// ### Usage
/// ```ab
/// if starts_with("hello world", "hello") {
///     echo "Starts with hello!"
/// }
/// ```
pub fun starts_with(text: Text, prefix: Text): Bool {
    trust $ [[ "{text}" == "{prefix}"* ]] $
    return status == 0
}

/// Checks if text ends with a value.
///
/// ### Usage
/// ```ab
/// if ends_with("hello world", "world") {
///     echo "Ends with world!"
/// }
/// ```
pub fun ends_with(text: Text, suffix: Text): Bool {
    trust $ [[ "{text}" == *"{suffix}" ]] $
    return status == 0
}

/// Returns a substring from `text` starting at the given `index` (0-based).
///
/// If `index` is negative, the substring starts from the end of `text` based on the absolute value of `index`.
/// If `length` is provided, the substring will include `length` characters; otherwise, it slices to the end of `text`.
/// If `length` is negative, an empty string is returned.
///
/// ### Usage
/// ```ab
/// let sub = slice("hello world", 6, 5)
/// echo sub // "world"
/// ```
pub fun slice(text: Text, index: Int, length: Int = 0): Text {
    let result = ""
    if length == 0: length = len(text) - index
    if length <= 0: return result
    trust $ {nameof result}="\$\{{nameof text}: {index}: {length}}" $
    return result
}

/// Returns the character from `text` at the specified `index` (0-based).
///
/// If `index` is negative, the substring starts from the end of `text` based on the absolute value of `index`.
///
/// ### Usage
/// ```ab
/// let ch = char_at("hello", 1)
/// echo ch // "e"
/// ```
pub fun char_at(text: Text, index: Int): Text {
    let result = ""
    trust $ {nameof result}="\$\{{nameof text}:{index}:1}" $
    return result
}

/// Capitalize the first letter of the given `text`.
///
/// ### Usage
/// ```ab
/// let cap = capitalized("hello")
/// echo cap // "Hello"
/// ```
#[allow_absurd_cast]
pub fun capitalized(text: Text): Text {
    trust {
        if len(text) == 0 {
            return text
        }
        if bash_version() >= [4] {
            return $ echo "\$\{{nameof text}^}" $
        }
        if sed_version() == SED_VERSION_GNU {
            // GNU sed supports \U
            return $ echo "{text}" | sed "s/^\(.\)/\U\1/" $
        }
        const first_letter = uppercase(char_at(text, 0))
        return first_letter + slice(text, 1)
    }
}

/// Pads `text` with the specified `pad` character on left until it reaches the desired `length`.
///
/// ### Usage
/// ```ab
/// let padded = lpad("42", "0", 5)
/// echo padded // "00042"
/// ```
pub fun lpad(text: Text, pad: Text, length: Int): Text {
    if length <= len(text): return text
    length = len(text) - length
    pad = trust $ printf "%{length}s" "" | tr " " "{pad}" $
    return pad + text
}

/// Pads `text` with the specified `pad` character on the right until it reaches the desired `length`.
///
/// ### Usage
/// ```ab
/// let padded = rpad("42", "0", 5)
/// echo padded // "42000"
/// ```
pub fun rpad(text: Text, pad: Text, length: Int): Text {
    if length <= len(text): return text
    length = len(text) - length
    pad = trust $ printf "%{length}s" "" | tr " " "{pad}" $
    return text + pad
}

/// Pads `text` with zeros on the left until it reaches the desired `length`.
///
/// ### Usage
/// ```ab
/// let padded = zfill("42", 5)
/// echo padded // "00042"
/// ```
pub fun zfill(text: Text, length: Int): Text {
    return lpad(text, "0", length)
}
